---
title: Logs, Metrics, and Nozzles
owner: Services
---

This topic explains how to integrate PCF services with Cloud Foundry's logging system, the _Loggregator_, by writing to or reading from its _Firehose_ endpoint.

## <a id="overview"></a> Overview

Cloud Foundry's logging system, _Loggregator_, sends logs and metrics aggregated from PCF apps and platform components to a single endpoint, the _Firehose_. Your tile can integrate its service with the Firehose in two ways:

* By sending your service component logs and metrics to the Firehose, to be streamed along with core PCF platform component logs and metrics.

* By installing a _nozzle_ on the Firehose. A nozzle directs Firehose data to be consumed by external services or apps. This can enable a service to:
  - Drain metrics to an external dashboard product, for system operators
  - Send HTTP request details to search or analysis tools
  - Drain app logs to an external system 
  - [Auto-scale itself](https://youtu.be/skJKvQfpKD4?t=1021) based on Firehose metrics
  
[Firehose-to-syslog](https://github.com/cloudfoundry-community/firehose-to-syslog) is a real world, production example of a nozzle.

## <a id="firehose"></a> Firehose Communication

PCF components publish logs and metrics to the Firehose through Metron agent processes running locally on the component VMs. Metron agents add the data to the Loggregator system by writing it to Loggregator's [etcd](https://coreos.com/etcd/) key-value store via a [gRPC](https://coreos.com/etcd/docs/latest/op-guide/grpc_proxy.html) proxy. The [Overview of the Loggregator System](https://docs.cloudfoundry.org/loggregator/architecture.html) topic shows how logs and metrics travel from PCF system components to the Firehose.

PCF service component VMs can publish logs and metrics the same way, by running a Metron agent that writes to etcd. In PCF v1.10 and higher, components can only communicate with `etcd` securely via `https` protocol. Earlier versions of PCF allowed both encrypted `https` and unencrypted `http` communications with etcd.

### <a id="https"></a> Secure HTTPS Protocol: PCF 1.10+

To enable a service component to supply logs and metrics to the Firehose through encrypted communications, include a Metron agent and a Consul agent in its template definitions.

The Metron definition includes double-paren properties that define a keypair to access etcd. The Consul definition includes double-paren properties for securely looking up the IP addresses of the etcd nodes at `cf-etcd.service.cf.internal`. This avoids hard-coding the etcd server addresses.

For example:


```
name: service
label: Service
templates:
  - name: consul
    release: consul
  - name: metron_agent
    release: loggregator
  - name: service
    release: service
manifest: |
  metron_agent:
    deployment: cf-my-service
    etcd:
      client_cert: (( ..cf.properties.cf_etcd_client_cert.cert_pem ))
      client_key: (( ..cf.properties.cf_etcd_client_cert.private_key_pem ))
  metron_endpoint:
    shared_secret: (( ..cf.doppler.shared_secret_credentials.password ))
  loggregator:
    etcd:
      require_ssl: true
      machines: ['cf-etcd.service.cf.internal']
      ca_cert: (( $ops_manager.ca_certificate ))
  consul:
    encrypt_keys:
    - (( ..cf.properties.consul_encrypt_key.value ))
    ca_cert: (( $ops_manager.ca_certificate ))
    agent_cert: (( ..cf.properties.consul_agent_cert.cert_pem ))
    agent_key: (( ..cf.properties.consul_agent_cert.private_key_pem ))
    agent:
      domain: cf.internal
      servers:
        lan: (( ..cf.consul_server.ips ))
```

### <a id="http"></a> HTTP Protocol: PCF 1.9 and Earlier

In PCF v1.9, service components can publish logs and metrics to the Firehose encrypted or unencrypted. In v1.8 and earlier releases, components only communicate their data unencrypted.

To enable unencrypted communications with etcd, define a Metron agent and list the addresses of the etcd servers as follows in the template definitions:

```
name: service
label: Service
templates:
  - name: metron_agent
    release: loggregator
  - name: service
    release: service
manifest: |
  metron_agent:
    deployment: cf-my-service
  metron_endpoint:
    shared_secret: (( ..cf.doppler.shared_secret_credentials.password ))
  loggregator:
    etcd:
      machines: (( ..cf.etcd_server.ips ))
```

## <a id="nozzle"></a> Nozzles

A nozzle is a component dedicated to reading and processing data that streams from the Firehose. A service tile can install a nozzle as either a managed service, with package type `bosh-release`; or as an app pushed to Elastic Runtime, with the package type `app`.

### <a id="develop"></a> Develop a Nozzle

Pivotal recommends developing a nozzle in Go, to leverage the
[NOAA library](https://github.com/cloudfoundry/noaa).
NOAA does the heavy lifting of establishing
an authenticated websocket connection to the logging system
as well as de-serializing the protocol buffers.

Draining the logs consists of:

1. Authenticating
1. Establishing a connection to the logging system
1. Forwarding events on to their ultimate destination

Authenticate by fetching a token from [UAA](https://github.com/cloudfoundry/uaa)
with a client having the `doppler.firehose` scope:

```go
	uaaClient, err := uaago.NewClient(uaaUrl)
	if err != nil {
		panic(err)
	}

	token, err := uaaClient.GetAuthToken(username, password, skipSSL)
	if err != nil {
		panic(err)
	}
```

Using the token, create a consumer and connect to the Firehose with a subscription id.
The id is important, since the Firehose looks for connections having the same id and only
sends an event to one of those connections. This is how a nozzle developer can prevent
message loss during upgrades an other deployments: run at least two instances.

```go
	consumer := consumer.New(config.TrafficControllerURL, &tls.Config{
		InsecureSkipVerify: config.SkipSSL,
	}, nil)
	events, errors := consumer.Firehose(firehoseSubscriptionID, token)
```

`Firehose` will give back two channels: one for events and a second for errors.

The events channel receives six different types of events.

* ValueMetric: Some platform metric at a point in time, emitted by platform components. For example, how many `2xx` responses the router has sent out.
* CounterEvent: An incrementing counter, emitted by platform components. For example, a Diego cell's remaining memory capacity.
* Error: An error.
* HttpStartStop: HTTP request details, including both application and platform requests.
* LogMessage: A log message for an individual app.
* ContainerMetric: Application container information. For example, memory used.

For the full details on events, see the
[dropsonde protocol](https://github.com/cloudfoundry/dropsonde-protocol/tree/master/events).

The above events show how this data targets two different personae:
platform operators and application developers. Keep this in mind when designing an integration.

Having `doppler.firehose` scope gets a nozzle data for *every* application as well as the platform. 
Any filtering based on the event payload is the nozzle implementor's responsibility.
An advanced integration could do something like combine a
[service broker](service-brokers.html) with a nozzle to:

* Let application developers opt-in to logging (implementing filtering in the nozzle)
* Establish [SSO](https://docs.cloudfoundry.org/services/dashboard-sso.html) exchange for authentication such that developers only can access logs for their space's apps

For a full working example (suitable as an integration starting point),
see [firehose-nozzle](https://github.com/cf-platform-eng/firehose-nozzle).

### <a id="deploy"></a> Deploy a Nozzle

Once you've build a nozzle, you can deploy it as either a managed service or as an app.

#### <a id="nozzle-service"></a> As a Managed Service

Visit [managed service](managed.html)
for more details on what it means to be a managed service.

See also this
[example nozzle BOSH release](https://github.com/cloudfoundry-incubator/example-nozzle-release).

#### <a id="nozzle-app"></a> As an App

You can also deploy the nozzle as an app on Elastic Runtime.
Visit the Tile Generator's
[section on pushed applications](tile-generator.html#pushed-applications)
for more details.

### <a id="examples"></a> Example Nozzles

There are several open source examples you could use
as a reference for building your nozzle

[firehose-nozzle](https://github.com/cf-platform-eng/firehose-nozzle)

  * Example that simply writes to standard out
  * Useful starting point: scaffolding, tests, etc are in place

[example-nozzle](https://github.com/cloudfoundry-incubator/example-nozzle)

  * A single file implementation with no tests: as minimal as things can get


[gcp-tools-release](https://github.com/cloudfoundry-community/gcp-tools-release)

  * In addition to Nozzle data, it drains component syslogs and health data
  * Shows how to do a bosh-addon (for additional data outside a nozzle)
  * Nozzle is managed via bosh
  * Raw logs and metrics data take different paths in the source

[firehose-to-syslog](https://github.com/cloudfoundry-community/firehose-to-syslog)

  * Includes implementation code that adds additional metadata (potentially needed for acl)
      - Application name
      - Space guid & name
      - Org guid & name
  * [logsearch-for-cloudfoundry](https://github.com/cloudfoundry-community/logsearch-for-cloudfoundry) packages this nozzle as a BOSH release

[splunk-firehose-nozzle](https://github.com/cf-platform-eng/splunk-firehose-nozzle) and
[splunk-firehose-nozzle-release](https://github.com/cf-platform-eng/splunk-firehose-nozzle-release)

  * Source code based on `firehose-to-syslog`
  * Packaged as a [BOSH release](./bosh-release.html)

[datadog-firehose-nozzle](https://github.com/cloudfoundry-incubator/datadog-firehose-nozzle)

  * Another real world implementation

## <a id="resources"></a> Other Resources

* CF Summit Video [Monitoring Cloud Foundry: Learning about the Firehose](https://youtu.be/skJKvQfpKD4)

* [Loggregator github repo](https://github.com/cloudfoundry/loggregator/)

* [Overview of the Loggregator System](https://docs.cloudfoundry.org/loggregator/architecture.html)

* [Loggregator's Slack Channel](https://cloudfoundry.slack.com/messages/loggregator/)

